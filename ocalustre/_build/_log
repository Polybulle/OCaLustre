### Starting build.
# Target: foo.ml.depends, tags: { annot, bin_annot, extension:ml, file:foo.ml, ocaml, ocamldep, package(compiler-libs.common), package(ppx_tools.metaquot), quiet, traverse }
/home/steven/.opam/4.02.2/bin/ocamlfind ocamldep -modules foo.ml > foo.ml.depends
# Target: foo.cmo, tags: { annot, bin_annot, byte, compile, extension:cmo, extension:ml, file:foo.cmo, file:foo.ml, implem, ocaml, package(compiler-libs.common), package(ppx_tools.metaquot), quiet, traverse }
/home/steven/.opam/4.02.2/bin/ocamlfind ocamlc -c -ppx ./ppx_lustre.native -dsource -I /home/steven/.opam/4.02.2/lib/ocaml -annot -bin-annot -o foo.cmo foo.ml
+ /home/steven/.opam/4.02.2/bin/ocamlfind ocamlc -c -ppx ./ppx_lustre.native -dsource -I /home/steven/.opam/4.02.2/lib/ocaml -annot -bin-annot -o foo.cmo foo.ml
module Option =
  struct let get o = match o with | None  -> failwith "non" | Some x -> x end
let edge () =
  let init = ref (Some true) in
  let edge_step x =
    let y = if Option.get (!init) then false else x && x in
    init := (Some false); y in
  edge_step
let entiers () =
  let init = ref (Some true) in
  let pre_n = ref None in
  let entiers_step () =
    let n = (if Option.get (!init) then 0 else Option.get (!pre_n)) + 1 in
    init := (Some false); pre_n := (Some n); n in
  entiers_step
let main () =
  let entiers_step_1 = entiers () in
  let entiers_step_2 = entiers () in
  let main_step () =
    let a = entiers_step_1 () in let b = entiers_step_2 () in (a, b) in
  main_step
let _ =
  let main_init = main () in
  while true do
    let (a,b) = main_init () in
    print_int a; print_int b; print_endline ""; Unix.sleep 1 done
# Target: foo.byte, tags: { annot, bin_annot, byte, dont_link_with, extension:byte, file:foo.byte, link, ocaml, program, quiet, traverse }
/home/steven/.opam/4.02.2/bin/ocamlfind ocamlc -I /home/steven/.opam/4.02.2/lib/ocaml unix.cma -linkpkg foo.cmo -o foo.byte
# Compilation successful.
